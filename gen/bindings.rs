/* automatically generated by rust-bindgen 0.59.2 */

#[doc = " Vertex attribute stream"]
#[doc = " Each element takes size bytes, beginning at data, with stride controlling the spacing between successive elements (stride >= size)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct meshopt_Stream {
    pub data: *const ::std::os::raw::c_void,
    pub size: usize,
    pub stride: usize,
}
extern "C" {
    #[doc = " Generates a vertex remap table from the vertex buffer and an optional index buffer and returns number of unique vertices"]
    #[doc = " As a result, all vertices that are binary equivalent map to the same (new) location, with no gaps in the resulting sequence."]
    #[doc = " Resulting remap table maps old vertices to new vertices and can be used in meshopt_remapVertexBuffer/meshopt_remapIndexBuffer."]
    #[doc = " Note that binary equivalence considers all vertex_size bytes, including padding which should be zero-initialized."]
    #[doc = ""]
    #[doc = " destination must contain enough space for the resulting remap table (vertex_count elements)"]
    #[doc = " indices can be NULL if the input is unindexed"]
    pub fn meshopt_generateVertexRemap(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertices: *const ::std::os::raw::c_void,
        vertex_count: usize,
        vertex_size: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Generates a vertex remap table from multiple vertex streams and an optional index buffer and returns number of unique vertices"]
    #[doc = " As a result, all vertices that are binary equivalent map to the same (new) location, with no gaps in the resulting sequence."]
    #[doc = " Resulting remap table maps old vertices to new vertices and can be used in meshopt_remapVertexBuffer/meshopt_remapIndexBuffer."]
    #[doc = " To remap vertex buffers, you will need to call meshopt_remapVertexBuffer for each vertex stream."]
    #[doc = " Note that binary equivalence considers all size bytes in each stream, including padding which should be zero-initialized."]
    #[doc = ""]
    #[doc = " destination must contain enough space for the resulting remap table (vertex_count elements)"]
    #[doc = " indices can be NULL if the input is unindexed"]
    #[doc = " stream_count must be <= 16"]
    pub fn meshopt_generateVertexRemapMulti(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
        streams: *const meshopt_Stream,
        stream_count: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Generates vertex buffer from the source vertex buffer and remap table generated by meshopt_generateVertexRemap"]
    #[doc = ""]
    #[doc = " destination must contain enough space for the resulting vertex buffer (unique_vertex_count elements, returned by meshopt_generateVertexRemap)"]
    #[doc = " vertex_count should be the initial vertex count and not the value returned by meshopt_generateVertexRemap"]
    pub fn meshopt_remapVertexBuffer(
        destination: *mut ::std::os::raw::c_void,
        vertices: *const ::std::os::raw::c_void,
        vertex_count: usize,
        vertex_size: usize,
        remap: *const ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Generate index buffer from the source index buffer and remap table generated by meshopt_generateVertexRemap"]
    #[doc = ""]
    #[doc = " destination must contain enough space for the resulting index buffer (index_count elements)"]
    #[doc = " indices can be NULL if the input is unindexed"]
    pub fn meshopt_remapIndexBuffer(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        remap: *const ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Generate index buffer that can be used for more efficient rendering when only a subset of the vertex attributes is necessary"]
    #[doc = " All vertices that are binary equivalent (wrt first vertex_size bytes) map to the first vertex in the original vertex buffer."]
    #[doc = " This makes it possible to use the index buffer for Z pre-pass or shadowmap rendering, while using the original index buffer for regular rendering."]
    #[doc = " Note that binary equivalence considers all vertex_size bytes, including padding which should be zero-initialized."]
    #[doc = ""]
    #[doc = " destination must contain enough space for the resulting index buffer (index_count elements)"]
    pub fn meshopt_generateShadowIndexBuffer(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertices: *const ::std::os::raw::c_void,
        vertex_count: usize,
        vertex_size: usize,
        vertex_stride: usize,
    );
}
extern "C" {
    #[doc = " Generate index buffer that can be used for more efficient rendering when only a subset of the vertex attributes is necessary"]
    #[doc = " All vertices that are binary equivalent (wrt specified streams) map to the first vertex in the original vertex buffer."]
    #[doc = " This makes it possible to use the index buffer for Z pre-pass or shadowmap rendering, while using the original index buffer for regular rendering."]
    #[doc = " Note that binary equivalence considers all size bytes in each stream, including padding which should be zero-initialized."]
    #[doc = ""]
    #[doc = " destination must contain enough space for the resulting index buffer (index_count elements)"]
    #[doc = " stream_count must be <= 16"]
    pub fn meshopt_generateShadowIndexBufferMulti(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
        streams: *const meshopt_Stream,
        stream_count: usize,
    );
}
extern "C" {
    #[doc = " Generate index buffer that can be used as a geometry shader input with triangle adjacency topology"]
    #[doc = " Each triangle is converted into a 6-vertex patch with the following layout:"]
    #[doc = " - 0, 2, 4: original triangle vertices"]
    #[doc = " - 1, 3, 5: vertices adjacent to edges 02, 24 and 40"]
    #[doc = " The resulting patch can be rendered with geometry shaders using e.g. VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY."]
    #[doc = " This can be used to implement algorithms like silhouette detection/expansion and other forms of GS-driven rendering."]
    #[doc = ""]
    #[doc = " destination must contain enough space for the resulting index buffer (index_count*2 elements)"]
    #[doc = " vertex_positions should have float3 position in the first 12 bytes of each vertex"]
    pub fn meshopt_generateAdjacencyIndexBuffer(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
    );
}
extern "C" {
    #[doc = " Generate index buffer that can be used for PN-AEN tessellation with crack-free displacement"]
    #[doc = " Each triangle is converted into a 12-vertex patch with the following layout:"]
    #[doc = " - 0, 1, 2: original triangle vertices"]
    #[doc = " - 3, 4: opposing edge for edge 0, 1"]
    #[doc = " - 5, 6: opposing edge for edge 1, 2"]
    #[doc = " - 7, 8: opposing edge for edge 2, 0"]
    #[doc = " - 9, 10, 11: dominant vertices for corners 0, 1, 2"]
    #[doc = " The resulting patch can be rendered with hardware tessellation using PN-AEN and displacement mapping."]
    #[doc = " See \"Tessellation on Any Budget\" (John McDonald, GDC 2011) for implementation details."]
    #[doc = ""]
    #[doc = " destination must contain enough space for the resulting index buffer (index_count*4 elements)"]
    #[doc = " vertex_positions should have float3 position in the first 12 bytes of each vertex"]
    pub fn meshopt_generateTessellationIndexBuffer(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
    );
}
extern "C" {
    #[doc = " Vertex transform cache optimizer"]
    #[doc = " Reorders indices to reduce the number of GPU vertex shader invocations"]
    #[doc = " If index buffer contains multiple ranges for multiple draw calls, this functions needs to be called on each range individually."]
    #[doc = ""]
    #[doc = " destination must contain enough space for the resulting index buffer (index_count elements)"]
    pub fn meshopt_optimizeVertexCache(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
    );
}
extern "C" {
    #[doc = " Vertex transform cache optimizer for strip-like caches"]
    #[doc = " Produces inferior results to meshopt_optimizeVertexCache from the GPU vertex cache perspective"]
    #[doc = " However, the resulting index order is more optimal if the goal is to reduce the triangle strip length or improve compression efficiency"]
    #[doc = ""]
    #[doc = " destination must contain enough space for the resulting index buffer (index_count elements)"]
    pub fn meshopt_optimizeVertexCacheStrip(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
    );
}
extern "C" {
    #[doc = " Vertex transform cache optimizer for FIFO caches"]
    #[doc = " Reorders indices to reduce the number of GPU vertex shader invocations"]
    #[doc = " Generally takes ~3x less time to optimize meshes but produces inferior results compared to meshopt_optimizeVertexCache"]
    #[doc = " If index buffer contains multiple ranges for multiple draw calls, this functions needs to be called on each range individually."]
    #[doc = ""]
    #[doc = " destination must contain enough space for the resulting index buffer (index_count elements)"]
    #[doc = " cache_size should be less than the actual GPU cache size to avoid cache thrashing"]
    pub fn meshopt_optimizeVertexCacheFifo(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
        cache_size: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Overdraw optimizer"]
    #[doc = " Reorders indices to reduce the number of GPU vertex shader invocations and the pixel overdraw"]
    #[doc = " If index buffer contains multiple ranges for multiple draw calls, this functions needs to be called on each range individually."]
    #[doc = ""]
    #[doc = " destination must contain enough space for the resulting index buffer (index_count elements)"]
    #[doc = " indices must contain index data that is the result of meshopt_optimizeVertexCache (*not* the original mesh indices!)"]
    #[doc = " vertex_positions should have float3 position in the first 12 bytes of each vertex"]
    #[doc = " threshold indicates how much the overdraw optimizer can degrade vertex cache efficiency (1.05 = up to 5%) to reduce overdraw more efficiently"]
    pub fn meshopt_optimizeOverdraw(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
        threshold: f32,
    );
}
extern "C" {
    #[doc = " Vertex fetch cache optimizer"]
    #[doc = " Reorders vertices and changes indices to reduce the amount of GPU memory fetches during vertex processing"]
    #[doc = " Returns the number of unique vertices, which is the same as input vertex count unless some vertices are unused"]
    #[doc = " This functions works for a single vertex stream; for multiple vertex streams, use meshopt_optimizeVertexFetchRemap + meshopt_remapVertexBuffer for each stream."]
    #[doc = ""]
    #[doc = " destination must contain enough space for the resulting vertex buffer (vertex_count elements)"]
    #[doc = " indices is used both as an input and as an output index buffer"]
    pub fn meshopt_optimizeVertexFetch(
        destination: *mut ::std::os::raw::c_void,
        indices: *mut ::std::os::raw::c_uint,
        index_count: usize,
        vertices: *const ::std::os::raw::c_void,
        vertex_count: usize,
        vertex_size: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Vertex fetch cache optimizer"]
    #[doc = " Generates vertex remap to reduce the amount of GPU memory fetches during vertex processing"]
    #[doc = " Returns the number of unique vertices, which is the same as input vertex count unless some vertices are unused"]
    #[doc = " The resulting remap table should be used to reorder vertex/index buffers using meshopt_remapVertexBuffer/meshopt_remapIndexBuffer"]
    #[doc = ""]
    #[doc = " destination must contain enough space for the resulting remap table (vertex_count elements)"]
    pub fn meshopt_optimizeVertexFetchRemap(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Index buffer encoder"]
    #[doc = " Encodes index data into an array of bytes that is generally much smaller (<1.5 bytes/triangle) and compresses better (<1 bytes/triangle) compared to original."]
    #[doc = " Input index buffer must represent a triangle list."]
    #[doc = " Returns encoded data size on success, 0 on error; the only error condition is if buffer doesn't have enough space"]
    #[doc = " For maximum efficiency the index buffer being encoded has to be optimized for vertex cache and vertex fetch first."]
    #[doc = ""]
    #[doc = " buffer must contain enough space for the encoded index buffer (use meshopt_encodeIndexBufferBound to compute worst case size)"]
    pub fn meshopt_encodeIndexBuffer(
        buffer: *mut ::std::os::raw::c_uchar,
        buffer_size: usize,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
    ) -> usize;
}
extern "C" {
    pub fn meshopt_encodeIndexBufferBound(index_count: usize, vertex_count: usize) -> usize;
}
extern "C" {
    #[doc = " Set index encoder format version"]
    #[doc = " version must specify the data format version to encode; valid values are 0 (decodable by all library versions) and 1 (decodable by 0.14+)"]
    pub fn meshopt_encodeIndexVersion(version: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Index buffer decoder"]
    #[doc = " Decodes index data from an array of bytes generated by meshopt_encodeIndexBuffer"]
    #[doc = " Returns 0 if decoding was successful, and an error code otherwise"]
    #[doc = " The decoder is safe to use for untrusted input, but it may produce garbage data (e.g. out of range indices)."]
    #[doc = ""]
    #[doc = " destination must contain enough space for the resulting index buffer (index_count elements)"]
    pub fn meshopt_decodeIndexBuffer(
        destination: *mut ::std::os::raw::c_void,
        index_count: usize,
        index_size: usize,
        buffer: *const ::std::os::raw::c_uchar,
        buffer_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Index sequence encoder"]
    #[doc = " Encodes index sequence into an array of bytes that is generally smaller and compresses better compared to original."]
    #[doc = " Input index sequence can represent arbitrary topology; for triangle lists meshopt_encodeIndexBuffer is likely to be better."]
    #[doc = " Returns encoded data size on success, 0 on error; the only error condition is if buffer doesn't have enough space"]
    #[doc = ""]
    #[doc = " buffer must contain enough space for the encoded index sequence (use meshopt_encodeIndexSequenceBound to compute worst case size)"]
    pub fn meshopt_encodeIndexSequence(
        buffer: *mut ::std::os::raw::c_uchar,
        buffer_size: usize,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
    ) -> usize;
}
extern "C" {
    pub fn meshopt_encodeIndexSequenceBound(index_count: usize, vertex_count: usize) -> usize;
}
extern "C" {
    #[doc = " Index sequence decoder"]
    #[doc = " Decodes index data from an array of bytes generated by meshopt_encodeIndexSequence"]
    #[doc = " Returns 0 if decoding was successful, and an error code otherwise"]
    #[doc = " The decoder is safe to use for untrusted input, but it may produce garbage data (e.g. out of range indices)."]
    #[doc = ""]
    #[doc = " destination must contain enough space for the resulting index sequence (index_count elements)"]
    pub fn meshopt_decodeIndexSequence(
        destination: *mut ::std::os::raw::c_void,
        index_count: usize,
        index_size: usize,
        buffer: *const ::std::os::raw::c_uchar,
        buffer_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Vertex buffer encoder"]
    #[doc = " Encodes vertex data into an array of bytes that is generally smaller and compresses better compared to original."]
    #[doc = " Returns encoded data size on success, 0 on error; the only error condition is if buffer doesn't have enough space"]
    #[doc = " This function works for a single vertex stream; for multiple vertex streams, call meshopt_encodeVertexBuffer for each stream."]
    #[doc = " Note that all vertex_size bytes of each vertex are encoded verbatim, including padding which should be zero-initialized."]
    #[doc = ""]
    #[doc = " buffer must contain enough space for the encoded vertex buffer (use meshopt_encodeVertexBufferBound to compute worst case size)"]
    pub fn meshopt_encodeVertexBuffer(
        buffer: *mut ::std::os::raw::c_uchar,
        buffer_size: usize,
        vertices: *const ::std::os::raw::c_void,
        vertex_count: usize,
        vertex_size: usize,
    ) -> usize;
}
extern "C" {
    pub fn meshopt_encodeVertexBufferBound(vertex_count: usize, vertex_size: usize) -> usize;
}
extern "C" {
    #[doc = " Set vertex encoder format version"]
    #[doc = " version must specify the data format version to encode; valid values are 0 (decodable by all library versions)"]
    pub fn meshopt_encodeVertexVersion(version: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Vertex buffer decoder"]
    #[doc = " Decodes vertex data from an array of bytes generated by meshopt_encodeVertexBuffer"]
    #[doc = " Returns 0 if decoding was successful, and an error code otherwise"]
    #[doc = " The decoder is safe to use for untrusted input, but it may produce garbage data."]
    #[doc = ""]
    #[doc = " destination must contain enough space for the resulting vertex buffer (vertex_count * vertex_size bytes)"]
    pub fn meshopt_decodeVertexBuffer(
        destination: *mut ::std::os::raw::c_void,
        vertex_count: usize,
        vertex_size: usize,
        buffer: *const ::std::os::raw::c_uchar,
        buffer_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Vertex buffer filters"]
    #[doc = " These functions can be used to filter output of meshopt_decodeVertexBuffer in-place."]
    #[doc = ""]
    #[doc = " meshopt_decodeFilterOct decodes octahedral encoding of a unit vector with K-bit (K <= 16) signed X/Y as an input; Z must store 1.0f."]
    #[doc = " Each component is stored as an 8-bit or 16-bit normalized integer; stride must be equal to 4 or 8. W is preserved as is."]
    #[doc = ""]
    #[doc = " meshopt_decodeFilterQuat decodes 3-component quaternion encoding with K-bit (4 <= K <= 16) component encoding and a 2-bit component index indicating which component to reconstruct."]
    #[doc = " Each component is stored as an 16-bit integer; stride must be equal to 8."]
    #[doc = ""]
    #[doc = " meshopt_decodeFilterExp decodes exponential encoding of floating-point data with 8-bit exponent and 24-bit integer mantissa as 2^E*M."]
    #[doc = " Each 32-bit component is decoded in isolation; stride must be divisible by 4."]
    pub fn meshopt_decodeFilterOct(
        buffer: *mut ::std::os::raw::c_void,
        count: usize,
        stride: usize,
    );
}
extern "C" {
    pub fn meshopt_decodeFilterQuat(
        buffer: *mut ::std::os::raw::c_void,
        count: usize,
        stride: usize,
    );
}
extern "C" {
    pub fn meshopt_decodeFilterExp(
        buffer: *mut ::std::os::raw::c_void,
        count: usize,
        stride: usize,
    );
}
pub const meshopt_EncodeExpMode_meshopt_EncodeExpSeparate: meshopt_EncodeExpMode = 0;
pub const meshopt_EncodeExpMode_meshopt_EncodeExpSharedVector: meshopt_EncodeExpMode = 1;
pub const meshopt_EncodeExpMode_meshopt_EncodeExpSharedComponent: meshopt_EncodeExpMode = 2;
#[doc = " Vertex buffer filter encoders"]
#[doc = " These functions can be used to encode data in a format that meshopt_decodeFilter can decode"]
#[doc = ""]
#[doc = " meshopt_encodeFilterOct encodes unit vectors with K-bit (K <= 16) signed X/Y as an output."]
#[doc = " Each component is stored as an 8-bit or 16-bit normalized integer; stride must be equal to 4 or 8. W is preserved as is."]
#[doc = " Input data must contain 4 floats for every vector (count*4 total)."]
#[doc = ""]
#[doc = " meshopt_encodeFilterQuat encodes unit quaternions with K-bit (4 <= K <= 16) component encoding."]
#[doc = " Each component is stored as an 16-bit integer; stride must be equal to 8."]
#[doc = " Input data must contain 4 floats for every quaternion (count*4 total)."]
#[doc = ""]
#[doc = " meshopt_encodeFilterExp encodes arbitrary (finite) floating-point data with 8-bit exponent and K-bit integer mantissa (1 <= K <= 24)."]
#[doc = " Exponent can be shared between all components of a given vector as defined by stride or all values of a given component; stride must be divisible by 4."]
#[doc = " Input data must contain stride/4 floats for every vector (count*stride/4 total)."]
pub type meshopt_EncodeExpMode = ::std::os::raw::c_int;
extern "C" {
    pub fn meshopt_encodeFilterOct(
        destination: *mut ::std::os::raw::c_void,
        count: usize,
        stride: usize,
        bits: ::std::os::raw::c_int,
        data: *const f32,
    );
}
extern "C" {
    pub fn meshopt_encodeFilterQuat(
        destination: *mut ::std::os::raw::c_void,
        count: usize,
        stride: usize,
        bits: ::std::os::raw::c_int,
        data: *const f32,
    );
}
extern "C" {
    pub fn meshopt_encodeFilterExp(
        destination: *mut ::std::os::raw::c_void,
        count: usize,
        stride: usize,
        bits: ::std::os::raw::c_int,
        data: *const f32,
        mode: meshopt_EncodeExpMode,
    );
}
extern "C" {
    #[doc = " Mesh simplifier"]
    #[doc = " Reduces the number of triangles in the mesh, attempting to preserve mesh appearance as much as possible"]
    #[doc = " The algorithm tries to preserve mesh topology and can stop short of the target goal based on topology constraints or target error."]
    #[doc = " If not all attributes from the input mesh are required, it's recommended to reindex the mesh using meshopt_generateShadowIndexBuffer prior to simplification."]
    #[doc = " Returns the number of indices after simplification, with destination containing new index data"]
    #[doc = " The resulting index buffer references vertices from the original vertex buffer."]
    #[doc = " If the original vertex data isn't required, creating a compact vertex buffer using meshopt_optimizeVertexFetch is recommended."]
    #[doc = ""]
    #[doc = " destination must contain enough space for the target index buffer, worst case is index_count elements (*not* target_index_count)!"]
    #[doc = " vertex_positions should have float3 position in the first 12 bytes of each vertex"]
    #[doc = " target_error represents the error relative to mesh extents that can be tolerated, e.g. 0.01 = 1% deformation; value range [0..1]"]
    #[doc = " options must be a bitmask composed of meshopt_SimplifyX options; 0 is a safe default"]
    #[doc = " result_error can be NULL; when it's not NULL, it will contain the resulting (relative) error after simplification"]
    pub fn meshopt_simplify(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
        target_index_count: usize,
        target_error: f32,
        options: ::std::os::raw::c_uint,
        result_error: *mut f32,
    ) -> usize;
}
extern "C" {
    #[doc = " Experimental: Mesh simplifier with attribute metric"]
    #[doc = " The algorithm ehnahces meshopt_simplify by incorporating attribute values into the error metric used to prioritize simplification order; see meshopt_simplify documentation for details."]
    #[doc = " Note that the number of attributes affects memory requirements and running time; this algorithm requires ~1.5x more memory and time compared to meshopt_simplify when using 4 scalar attributes."]
    #[doc = ""]
    #[doc = " vertex_attributes should have attribute_count floats for each vertex"]
    #[doc = " attribute_weights should have attribute_count floats in total; the weights determine relative priority of attributes between each other and wrt position. The recommended weight range is [1e-3..1e-1], assuming attribute data is in [0..1] range."]
    #[doc = " attribute_count must be <= 16"]
    #[doc = " vertex_lock can be NULL; when it's not NULL, it should have a value for each vertex; 1 denotes vertices that can't be moved"]
    #[doc = " TODO target_error/result_error currently use combined distance+attribute error; this may change in the future"]
    pub fn meshopt_simplifyWithAttributes(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
        vertex_attributes: *const f32,
        vertex_attributes_stride: usize,
        attribute_weights: *const f32,
        attribute_count: usize,
        vertex_lock: *const ::std::os::raw::c_uchar,
        target_index_count: usize,
        target_error: f32,
        options: ::std::os::raw::c_uint,
        result_error: *mut f32,
    ) -> usize;
}
extern "C" {
    #[doc = " Experimental: Mesh simplifier (sloppy)"]
    #[doc = " Reduces the number of triangles in the mesh, sacrificing mesh appearance for simplification performance"]
    #[doc = " The algorithm doesn't preserve mesh topology but can stop short of the target goal based on target error."]
    #[doc = " Returns the number of indices after simplification, with destination containing new index data"]
    #[doc = " The resulting index buffer references vertices from the original vertex buffer."]
    #[doc = " If the original vertex data isn't required, creating a compact vertex buffer using meshopt_optimizeVertexFetch is recommended."]
    #[doc = ""]
    #[doc = " destination must contain enough space for the target index buffer, worst case is index_count elements (*not* target_index_count)!"]
    #[doc = " vertex_positions should have float3 position in the first 12 bytes of each vertex"]
    #[doc = " target_error represents the error relative to mesh extents that can be tolerated, e.g. 0.01 = 1% deformation; value range [0..1]"]
    #[doc = " result_error can be NULL; when it's not NULL, it will contain the resulting (relative) error after simplification"]
    pub fn meshopt_simplifySloppy(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
        target_index_count: usize,
        target_error: f32,
        result_error: *mut f32,
    ) -> usize;
}
extern "C" {
    #[doc = " Experimental: Point cloud simplifier"]
    #[doc = " Reduces the number of points in the cloud to reach the given target"]
    #[doc = " Returns the number of points after simplification, with destination containing new index data"]
    #[doc = " The resulting index buffer references vertices from the original vertex buffer."]
    #[doc = " If the original vertex data isn't required, creating a compact vertex buffer using meshopt_optimizeVertexFetch is recommended."]
    #[doc = ""]
    #[doc = " destination must contain enough space for the target index buffer (target_vertex_count elements)"]
    #[doc = " vertex_positions should have float3 position in the first 12 bytes of each vertex"]
    #[doc = " vertex_colors should can be NULL; when it's not NULL, it should have float3 color in the first 12 bytes of each vertex"]
    pub fn meshopt_simplifyPoints(
        destination: *mut ::std::os::raw::c_uint,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
        vertex_colors: *const f32,
        vertex_colors_stride: usize,
        color_weight: f32,
        target_vertex_count: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Returns the error scaling factor used by the simplifier to convert between absolute and relative extents"]
    #[doc = ""]
    #[doc = " Absolute error must be *divided* by the scaling factor before passing it to meshopt_simplify as target_error"]
    #[doc = " Relative error returned by meshopt_simplify via result_error must be *multiplied* by the scaling factor to get absolute error."]
    pub fn meshopt_simplifyScale(
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
    ) -> f32;
}
extern "C" {
    #[doc = " Mesh stripifier"]
    #[doc = " Converts a previously vertex cache optimized triangle list to triangle strip, stitching strips using restart index or degenerate triangles"]
    #[doc = " Returns the number of indices in the resulting strip, with destination containing new index data"]
    #[doc = " For maximum efficiency the index buffer being converted has to be optimized for vertex cache first."]
    #[doc = " Using restart indices can result in ~10% smaller index buffers, but on some GPUs restart indices may result in decreased performance."]
    #[doc = ""]
    #[doc = " destination must contain enough space for the target index buffer, worst case can be computed with meshopt_stripifyBound"]
    #[doc = " restart_index should be 0xffff or 0xffffffff depending on index size, or 0 to use degenerate triangles"]
    pub fn meshopt_stripify(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
        restart_index: ::std::os::raw::c_uint,
    ) -> usize;
}
extern "C" {
    pub fn meshopt_stripifyBound(index_count: usize) -> usize;
}
extern "C" {
    #[doc = " Mesh unstripifier"]
    #[doc = " Converts a triangle strip to a triangle list"]
    #[doc = " Returns the number of indices in the resulting list, with destination containing new index data"]
    #[doc = ""]
    #[doc = " destination must contain enough space for the target index buffer, worst case can be computed with meshopt_unstripifyBound"]
    pub fn meshopt_unstripify(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        restart_index: ::std::os::raw::c_uint,
    ) -> usize;
}
extern "C" {
    pub fn meshopt_unstripifyBound(index_count: usize) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct meshopt_VertexCacheStatistics {
    pub vertices_transformed: ::std::os::raw::c_uint,
    pub warps_executed: ::std::os::raw::c_uint,
    pub acmr: f32,
    pub atvr: f32,
}
extern "C" {
    #[doc = " Vertex transform cache analyzer"]
    #[doc = " Returns cache hit statistics using a simplified FIFO model"]
    #[doc = " Results may not match actual GPU performance"]
    pub fn meshopt_analyzeVertexCache(
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
        cache_size: ::std::os::raw::c_uint,
        warp_size: ::std::os::raw::c_uint,
        primgroup_size: ::std::os::raw::c_uint,
    ) -> meshopt_VertexCacheStatistics;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct meshopt_OverdrawStatistics {
    pub pixels_covered: ::std::os::raw::c_uint,
    pub pixels_shaded: ::std::os::raw::c_uint,
    pub overdraw: f32,
}
extern "C" {
    #[doc = " Overdraw analyzer"]
    #[doc = " Returns overdraw statistics using a software rasterizer"]
    #[doc = " Results may not match actual GPU performance"]
    #[doc = ""]
    #[doc = " vertex_positions should have float3 position in the first 12 bytes of each vertex"]
    pub fn meshopt_analyzeOverdraw(
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
    ) -> meshopt_OverdrawStatistics;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct meshopt_VertexFetchStatistics {
    pub bytes_fetched: ::std::os::raw::c_uint,
    pub overfetch: f32,
}
extern "C" {
    #[doc = " Vertex fetch cache analyzer"]
    #[doc = " Returns cache hit statistics using a simplified direct mapped model"]
    #[doc = " Results may not match actual GPU performance"]
    pub fn meshopt_analyzeVertexFetch(
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
        vertex_size: usize,
    ) -> meshopt_VertexFetchStatistics;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct meshopt_Meshlet {
    pub vertex_offset: ::std::os::raw::c_uint,
    pub triangle_offset: ::std::os::raw::c_uint,
    pub vertex_count: ::std::os::raw::c_uint,
    pub triangle_count: ::std::os::raw::c_uint,
}
extern "C" {
    #[doc = " Meshlet builder"]
    #[doc = " Splits the mesh into a set of meshlets where each meshlet has a micro index buffer indexing into meshlet vertices that refer to the original vertex buffer"]
    #[doc = " The resulting data can be used to render meshes using NVidia programmable mesh shading pipeline, or in other cluster-based renderers."]
    #[doc = " When using buildMeshlets, vertex positions need to be provided to minimize the size of the resulting clusters."]
    #[doc = " When using buildMeshletsScan, for maximum efficiency the index buffer being converted has to be optimized for vertex cache first."]
    #[doc = ""]
    #[doc = " meshlets must contain enough space for all meshlets, worst case size can be computed with meshopt_buildMeshletsBound"]
    #[doc = " meshlet_vertices must contain enough space for all meshlets, worst case size is equal to max_meshlets * max_vertices"]
    #[doc = " meshlet_triangles must contain enough space for all meshlets, worst case size is equal to max_meshlets * max_triangles * 3"]
    #[doc = " vertex_positions should have float3 position in the first 12 bytes of each vertex"]
    #[doc = " max_vertices and max_triangles must not exceed implementation limits (max_vertices <= 255 - not 256!, max_triangles <= 512; max_triangles must be divisible by 4)"]
    #[doc = " cone_weight should be set to 0 when cone culling is not used, and a value between 0 and 1 otherwise to balance between cluster size and cone culling efficiency"]
    pub fn meshopt_buildMeshlets(
        meshlets: *mut meshopt_Meshlet,
        meshlet_vertices: *mut ::std::os::raw::c_uint,
        meshlet_triangles: *mut ::std::os::raw::c_uchar,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
        max_vertices: usize,
        max_triangles: usize,
        cone_weight: f32,
    ) -> usize;
}
extern "C" {
    pub fn meshopt_buildMeshletsScan(
        meshlets: *mut meshopt_Meshlet,
        meshlet_vertices: *mut ::std::os::raw::c_uint,
        meshlet_triangles: *mut ::std::os::raw::c_uchar,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
        max_vertices: usize,
        max_triangles: usize,
    ) -> usize;
}
extern "C" {
    pub fn meshopt_buildMeshletsBound(
        index_count: usize,
        max_vertices: usize,
        max_triangles: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Experimental: Meshlet optimizer"]
    #[doc = " Reorders meshlet vertices and triangles to maximize locality to improve rasterizer throughput"]
    #[doc = ""]
    #[doc = " meshlet_triangles and meshlet_vertices must refer to meshlet triangle and vertex index data; when buildMeshlets* is used, these"]
    #[doc = " need to be computed from meshlet's vertex_offset and triangle_offset"]
    #[doc = " triangle_count and vertex_count must not exceed implementation limits (vertex_count <= 255 - not 256!, triangle_count <= 512)"]
    pub fn meshopt_optimizeMeshlet(
        meshlet_vertices: *mut ::std::os::raw::c_uint,
        meshlet_triangles: *mut ::std::os::raw::c_uchar,
        triangle_count: usize,
        vertex_count: usize,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct meshopt_Bounds {
    pub center: [f32; 3usize],
    pub radius: f32,
    pub cone_apex: [f32; 3usize],
    pub cone_axis: [f32; 3usize],
    pub cone_cutoff: f32,
    pub cone_axis_s8: [::std::os::raw::c_schar; 3usize],
    pub cone_cutoff_s8: ::std::os::raw::c_schar,
}
extern "C" {
    #[doc = " Cluster bounds generator"]
    #[doc = " Creates bounding volumes that can be used for frustum, backface and occlusion culling."]
    #[doc = ""]
    #[doc = " For backface culling with orthographic projection, use the following formula to reject backfacing clusters:"]
    #[doc = "   dot(view, cone_axis) >= cone_cutoff"]
    #[doc = ""]
    #[doc = " For perspective projection, you can use the formula that needs cone apex in addition to axis & cutoff:"]
    #[doc = "   dot(normalize(cone_apex - camera_position), cone_axis) >= cone_cutoff"]
    #[doc = ""]
    #[doc = " Alternatively, you can use the formula that doesn't need cone apex and uses bounding sphere instead:"]
    #[doc = "   dot(normalize(center - camera_position), cone_axis) >= cone_cutoff + radius / length(center - camera_position)"]
    #[doc = " or an equivalent formula that doesn't have a singularity at center = camera_position:"]
    #[doc = "   dot(center - camera_position, cone_axis) >= cone_cutoff * length(center - camera_position) + radius"]
    #[doc = ""]
    #[doc = " The formula that uses the apex is slightly more accurate but needs the apex; if you are already using bounding sphere"]
    #[doc = " to do frustum/occlusion culling, the formula that doesn't use the apex may be preferable (for derivation see"]
    #[doc = " Real-Time Rendering 4th Edition, section 19.3)."]
    #[doc = ""]
    #[doc = " vertex_positions should have float3 position in the first 12 bytes of each vertex"]
    #[doc = " index_count/3 should be less than or equal to 512 (the function assumes clusters of limited size)"]
    pub fn meshopt_computeClusterBounds(
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
    ) -> meshopt_Bounds;
}
extern "C" {
    pub fn meshopt_computeMeshletBounds(
        meshlet_vertices: *const ::std::os::raw::c_uint,
        meshlet_triangles: *const ::std::os::raw::c_uchar,
        triangle_count: usize,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
    ) -> meshopt_Bounds;
}
extern "C" {
    #[doc = " Spatial sorter"]
    #[doc = " Generates a remap table that can be used to reorder points for spatial locality."]
    #[doc = " Resulting remap table maps old vertices to new vertices and can be used in meshopt_remapVertexBuffer."]
    #[doc = ""]
    #[doc = " destination must contain enough space for the resulting remap table (vertex_count elements)"]
    #[doc = " vertex_positions should have float3 position in the first 12 bytes of each vertex"]
    pub fn meshopt_spatialSortRemap(
        destination: *mut ::std::os::raw::c_uint,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
    );
}
extern "C" {
    #[doc = " Experimental: Spatial sorter"]
    #[doc = " Reorders triangles for spatial locality, and generates a new index buffer. The resulting index buffer can be used with other functions like optimizeVertexCache."]
    #[doc = ""]
    #[doc = " destination must contain enough space for the resulting index buffer (index_count elements)"]
    #[doc = " vertex_positions should have float3 position in the first 12 bytes of each vertex"]
    pub fn meshopt_spatialSortTriangles(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
    );
}
extern "C" {
    #[doc = " Set allocation callbacks"]
    #[doc = " These callbacks will be used instead of the default operator new/operator delete for all temporary allocations in the library."]
    #[doc = " Note that all algorithms only allocate memory for temporary use."]
    #[doc = " allocate/deallocate are always called in a stack-like order - last pointer to be allocated is deallocated first."]
    pub fn meshopt_setAllocator(
        allocate: ::std::option::Option<
            unsafe extern "C" fn(arg1: usize) -> *mut ::std::os::raw::c_void,
        >,
        deallocate: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
