/* automatically generated by rust-bindgen 0.70.1 */

#[doc = " Vertex attribute stream\n Each element takes size bytes, beginning at data, with stride controlling the spacing between successive elements (stride >= size)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct meshopt_Stream {
    pub data: *const ::std::os::raw::c_void,
    pub size: usize,
    pub stride: usize,
}
extern "C" {
    #[doc = " Generates a vertex remap table from the vertex buffer and an optional index buffer and returns number of unique vertices\n As a result, all vertices that are binary equivalent map to the same (new) location, with no gaps in the resulting sequence.\n Resulting remap table maps old vertices to new vertices and can be used in meshopt_remapVertexBuffer/meshopt_remapIndexBuffer.\n Note that binary equivalence considers all vertex_size bytes, including padding which should be zero-initialized.\n\n destination must contain enough space for the resulting remap table (vertex_count elements)\n indices can be NULL if the input is unindexed"]
    pub fn meshopt_generateVertexRemap(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertices: *const ::std::os::raw::c_void,
        vertex_count: usize,
        vertex_size: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Generates a vertex remap table from multiple vertex streams and an optional index buffer and returns number of unique vertices\n As a result, all vertices that are binary equivalent map to the same (new) location, with no gaps in the resulting sequence.\n Resulting remap table maps old vertices to new vertices and can be used in meshopt_remapVertexBuffer/meshopt_remapIndexBuffer.\n To remap vertex buffers, you will need to call meshopt_remapVertexBuffer for each vertex stream.\n Note that binary equivalence considers all size bytes in each stream, including padding which should be zero-initialized.\n\n destination must contain enough space for the resulting remap table (vertex_count elements)\n indices can be NULL if the input is unindexed\n stream_count must be <= 16"]
    pub fn meshopt_generateVertexRemapMulti(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
        streams: *const meshopt_Stream,
        stream_count: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Generates vertex buffer from the source vertex buffer and remap table generated by meshopt_generateVertexRemap\n\n destination must contain enough space for the resulting vertex buffer (unique_vertex_count elements, returned by meshopt_generateVertexRemap)\n vertex_count should be the initial vertex count and not the value returned by meshopt_generateVertexRemap"]
    pub fn meshopt_remapVertexBuffer(
        destination: *mut ::std::os::raw::c_void,
        vertices: *const ::std::os::raw::c_void,
        vertex_count: usize,
        vertex_size: usize,
        remap: *const ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Generate index buffer from the source index buffer and remap table generated by meshopt_generateVertexRemap\n\n destination must contain enough space for the resulting index buffer (index_count elements)\n indices can be NULL if the input is unindexed"]
    pub fn meshopt_remapIndexBuffer(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        remap: *const ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Generate index buffer that can be used for more efficient rendering when only a subset of the vertex attributes is necessary\n All vertices that are binary equivalent (wrt first vertex_size bytes) map to the first vertex in the original vertex buffer.\n This makes it possible to use the index buffer for Z pre-pass or shadowmap rendering, while using the original index buffer for regular rendering.\n Note that binary equivalence considers all vertex_size bytes, including padding which should be zero-initialized.\n\n destination must contain enough space for the resulting index buffer (index_count elements)"]
    pub fn meshopt_generateShadowIndexBuffer(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertices: *const ::std::os::raw::c_void,
        vertex_count: usize,
        vertex_size: usize,
        vertex_stride: usize,
    );
}
extern "C" {
    #[doc = " Generate index buffer that can be used for more efficient rendering when only a subset of the vertex attributes is necessary\n All vertices that are binary equivalent (wrt specified streams) map to the first vertex in the original vertex buffer.\n This makes it possible to use the index buffer for Z pre-pass or shadowmap rendering, while using the original index buffer for regular rendering.\n Note that binary equivalence considers all size bytes in each stream, including padding which should be zero-initialized.\n\n destination must contain enough space for the resulting index buffer (index_count elements)\n stream_count must be <= 16"]
    pub fn meshopt_generateShadowIndexBufferMulti(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
        streams: *const meshopt_Stream,
        stream_count: usize,
    );
}
extern "C" {
    #[doc = " Generate index buffer that can be used as a geometry shader input with triangle adjacency topology\n Each triangle is converted into a 6-vertex patch with the following layout:\n - 0, 2, 4: original triangle vertices\n - 1, 3, 5: vertices adjacent to edges 02, 24 and 40\n The resulting patch can be rendered with geometry shaders using e.g. VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY.\n This can be used to implement algorithms like silhouette detection/expansion and other forms of GS-driven rendering.\n\n destination must contain enough space for the resulting index buffer (index_count*2 elements)\n vertex_positions should have float3 position in the first 12 bytes of each vertex"]
    pub fn meshopt_generateAdjacencyIndexBuffer(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
    );
}
extern "C" {
    #[doc = " Generate index buffer that can be used for PN-AEN tessellation with crack-free displacement\n Each triangle is converted into a 12-vertex patch with the following layout:\n - 0, 1, 2: original triangle vertices\n - 3, 4: opposing edge for edge 0, 1\n - 5, 6: opposing edge for edge 1, 2\n - 7, 8: opposing edge for edge 2, 0\n - 9, 10, 11: dominant vertices for corners 0, 1, 2\n The resulting patch can be rendered with hardware tessellation using PN-AEN and displacement mapping.\n See \"Tessellation on Any Budget\" (John McDonald, GDC 2011) for implementation details.\n\n destination must contain enough space for the resulting index buffer (index_count*4 elements)\n vertex_positions should have float3 position in the first 12 bytes of each vertex"]
    pub fn meshopt_generateTessellationIndexBuffer(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
    );
}
extern "C" {
    #[doc = " Experimental: Generate index buffer that can be used for visibility buffer rendering and returns the size of the reorder table\n Each triangle's provoking vertex index is equal to primitive id; this allows passing it to the fragment shader using nointerpolate attribute.\n This is important for performance on hardware where primitive id can't be accessed efficiently in fragment shader.\n The reorder table stores the original vertex id for each vertex in the new index buffer, and should be used in the vertex shader to load vertex data.\n The provoking vertex is assumed to be the first vertex in the triangle; if this is not the case (OpenGL), rotate each triangle (abc -> bca) before rendering.\n For maximum efficiency the input index buffer should be optimized for vertex cache first.\n\n destination must contain enough space for the resulting index buffer (index_count elements)\n reorder must contain enough space for the worst case reorder table (vertex_count + index_count/3 elements)"]
    pub fn meshopt_generateProvokingIndexBuffer(
        destination: *mut ::std::os::raw::c_uint,
        reorder: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Vertex transform cache optimizer\n Reorders indices to reduce the number of GPU vertex shader invocations\n If index buffer contains multiple ranges for multiple draw calls, this functions needs to be called on each range individually.\n\n destination must contain enough space for the resulting index buffer (index_count elements)"]
    pub fn meshopt_optimizeVertexCache(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
    );
}
extern "C" {
    #[doc = " Vertex transform cache optimizer for strip-like caches\n Produces inferior results to meshopt_optimizeVertexCache from the GPU vertex cache perspective\n However, the resulting index order is more optimal if the goal is to reduce the triangle strip length or improve compression efficiency\n\n destination must contain enough space for the resulting index buffer (index_count elements)"]
    pub fn meshopt_optimizeVertexCacheStrip(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
    );
}
extern "C" {
    #[doc = " Vertex transform cache optimizer for FIFO caches\n Reorders indices to reduce the number of GPU vertex shader invocations\n Generally takes ~3x less time to optimize meshes but produces inferior results compared to meshopt_optimizeVertexCache\n If index buffer contains multiple ranges for multiple draw calls, this functions needs to be called on each range individually.\n\n destination must contain enough space for the resulting index buffer (index_count elements)\n cache_size should be less than the actual GPU cache size to avoid cache thrashing"]
    pub fn meshopt_optimizeVertexCacheFifo(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
        cache_size: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Overdraw optimizer\n Reorders indices to reduce the number of GPU vertex shader invocations and the pixel overdraw\n If index buffer contains multiple ranges for multiple draw calls, this functions needs to be called on each range individually.\n\n destination must contain enough space for the resulting index buffer (index_count elements)\n indices must contain index data that is the result of meshopt_optimizeVertexCache (*not* the original mesh indices!)\n vertex_positions should have float3 position in the first 12 bytes of each vertex\n threshold indicates how much the overdraw optimizer can degrade vertex cache efficiency (1.05 = up to 5%) to reduce overdraw more efficiently"]
    pub fn meshopt_optimizeOverdraw(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
        threshold: f32,
    );
}
extern "C" {
    #[doc = " Vertex fetch cache optimizer\n Reorders vertices and changes indices to reduce the amount of GPU memory fetches during vertex processing\n Returns the number of unique vertices, which is the same as input vertex count unless some vertices are unused\n This functions works for a single vertex stream; for multiple vertex streams, use meshopt_optimizeVertexFetchRemap + meshopt_remapVertexBuffer for each stream.\n\n destination must contain enough space for the resulting vertex buffer (vertex_count elements)\n indices is used both as an input and as an output index buffer"]
    pub fn meshopt_optimizeVertexFetch(
        destination: *mut ::std::os::raw::c_void,
        indices: *mut ::std::os::raw::c_uint,
        index_count: usize,
        vertices: *const ::std::os::raw::c_void,
        vertex_count: usize,
        vertex_size: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Vertex fetch cache optimizer\n Generates vertex remap to reduce the amount of GPU memory fetches during vertex processing\n Returns the number of unique vertices, which is the same as input vertex count unless some vertices are unused\n The resulting remap table should be used to reorder vertex/index buffers using meshopt_remapVertexBuffer/meshopt_remapIndexBuffer\n\n destination must contain enough space for the resulting remap table (vertex_count elements)"]
    pub fn meshopt_optimizeVertexFetchRemap(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Index buffer encoder\n Encodes index data into an array of bytes that is generally much smaller (<1.5 bytes/triangle) and compresses better (<1 bytes/triangle) compared to original.\n Input index buffer must represent a triangle list.\n Returns encoded data size on success, 0 on error; the only error condition is if buffer doesn't have enough space\n For maximum efficiency the index buffer being encoded has to be optimized for vertex cache and vertex fetch first.\n\n buffer must contain enough space for the encoded index buffer (use meshopt_encodeIndexBufferBound to compute worst case size)"]
    pub fn meshopt_encodeIndexBuffer(
        buffer: *mut ::std::os::raw::c_uchar,
        buffer_size: usize,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
    ) -> usize;
}
extern "C" {
    pub fn meshopt_encodeIndexBufferBound(index_count: usize, vertex_count: usize) -> usize;
}
extern "C" {
    #[doc = " Set index encoder format version\n version must specify the data format version to encode; valid values are 0 (decodable by all library versions) and 1 (decodable by 0.14+)"]
    pub fn meshopt_encodeIndexVersion(version: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Index buffer decoder\n Decodes index data from an array of bytes generated by meshopt_encodeIndexBuffer\n Returns 0 if decoding was successful, and an error code otherwise\n The decoder is safe to use for untrusted input, but it may produce garbage data (e.g. out of range indices).\n\n destination must contain enough space for the resulting index buffer (index_count elements)"]
    pub fn meshopt_decodeIndexBuffer(
        destination: *mut ::std::os::raw::c_void,
        index_count: usize,
        index_size: usize,
        buffer: *const ::std::os::raw::c_uchar,
        buffer_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get encoded index format version\n Returns format version of the encoded index buffer/sequence, or -1 if the buffer header is invalid\n Note that a non-negative value doesn't guarantee that the buffer will be decoded correctly if the input is malformed."]
    pub fn meshopt_decodeIndexVersion(
        buffer: *const ::std::os::raw::c_uchar,
        buffer_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Index sequence encoder\n Encodes index sequence into an array of bytes that is generally smaller and compresses better compared to original.\n Input index sequence can represent arbitrary topology; for triangle lists meshopt_encodeIndexBuffer is likely to be better.\n Returns encoded data size on success, 0 on error; the only error condition is if buffer doesn't have enough space\n\n buffer must contain enough space for the encoded index sequence (use meshopt_encodeIndexSequenceBound to compute worst case size)"]
    pub fn meshopt_encodeIndexSequence(
        buffer: *mut ::std::os::raw::c_uchar,
        buffer_size: usize,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
    ) -> usize;
}
extern "C" {
    pub fn meshopt_encodeIndexSequenceBound(index_count: usize, vertex_count: usize) -> usize;
}
extern "C" {
    #[doc = " Index sequence decoder\n Decodes index data from an array of bytes generated by meshopt_encodeIndexSequence\n Returns 0 if decoding was successful, and an error code otherwise\n The decoder is safe to use for untrusted input, but it may produce garbage data (e.g. out of range indices).\n\n destination must contain enough space for the resulting index sequence (index_count elements)"]
    pub fn meshopt_decodeIndexSequence(
        destination: *mut ::std::os::raw::c_void,
        index_count: usize,
        index_size: usize,
        buffer: *const ::std::os::raw::c_uchar,
        buffer_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Vertex buffer encoder\n Encodes vertex data into an array of bytes that is generally smaller and compresses better compared to original.\n Returns encoded data size on success, 0 on error; the only error condition is if buffer doesn't have enough space\n This function works for a single vertex stream; for multiple vertex streams, call meshopt_encodeVertexBuffer for each stream.\n Note that all vertex_size bytes of each vertex are encoded verbatim, including padding which should be zero-initialized.\n For maximum efficiency the vertex buffer being encoded has to be quantized and optimized for locality of reference (cache/fetch) first.\n\n buffer must contain enough space for the encoded vertex buffer (use meshopt_encodeVertexBufferBound to compute worst case size)"]
    pub fn meshopt_encodeVertexBuffer(
        buffer: *mut ::std::os::raw::c_uchar,
        buffer_size: usize,
        vertices: *const ::std::os::raw::c_void,
        vertex_count: usize,
        vertex_size: usize,
    ) -> usize;
}
extern "C" {
    pub fn meshopt_encodeVertexBufferBound(vertex_count: usize, vertex_size: usize) -> usize;
}
extern "C" {
    #[doc = " Experimental: Vertex buffer encoder\n Encodes vertex data just like meshopt_encodeVertexBuffer, but allows to override compression level.\n For compression level to take effect, the vertex encoding version must be set to 1 via meshopt_encodeVertexVersion.\n The default compression level implied by meshopt_encodeVertexBuffer is 2.\n\n level should be in the range [0, 3] with 0 being the fastest and 3 being the slowest and producing the best compression ratio."]
    pub fn meshopt_encodeVertexBufferLevel(
        buffer: *mut ::std::os::raw::c_uchar,
        buffer_size: usize,
        vertices: *const ::std::os::raw::c_void,
        vertex_count: usize,
        vertex_size: usize,
        level: ::std::os::raw::c_int,
    ) -> usize;
}
extern "C" {
    #[doc = " Set vertex encoder format version\n version must specify the data format version to encode; valid values are 0 (decodable by all library versions) and 1 (decodable by 0.23+)"]
    pub fn meshopt_encodeVertexVersion(version: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Vertex buffer decoder\n Decodes vertex data from an array of bytes generated by meshopt_encodeVertexBuffer\n Returns 0 if decoding was successful, and an error code otherwise\n The decoder is safe to use for untrusted input, but it may produce garbage data.\n\n destination must contain enough space for the resulting vertex buffer (vertex_count * vertex_size bytes)"]
    pub fn meshopt_decodeVertexBuffer(
        destination: *mut ::std::os::raw::c_void,
        vertex_count: usize,
        vertex_size: usize,
        buffer: *const ::std::os::raw::c_uchar,
        buffer_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get encoded vertex format version\n Returns format version of the encoded vertex buffer, or -1 if the buffer header is invalid\n Note that a non-negative value doesn't guarantee that the buffer will be decoded correctly if the input is malformed."]
    pub fn meshopt_decodeVertexVersion(
        buffer: *const ::std::os::raw::c_uchar,
        buffer_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Vertex buffer filters\n These functions can be used to filter output of meshopt_decodeVertexBuffer in-place.\n\n meshopt_decodeFilterOct decodes octahedral encoding of a unit vector with K-bit (K <= 16) signed X/Y as an input; Z must store 1.0f.\n Each component is stored as an 8-bit or 16-bit normalized integer; stride must be equal to 4 or 8. W is preserved as is.\n\n meshopt_decodeFilterQuat decodes 3-component quaternion encoding with K-bit (4 <= K <= 16) component encoding and a 2-bit component index indicating which component to reconstruct.\n Each component is stored as an 16-bit integer; stride must be equal to 8.\n\n meshopt_decodeFilterExp decodes exponential encoding of floating-point data with 8-bit exponent and 24-bit integer mantissa as 2^E*M.\n Each 32-bit component is decoded in isolation; stride must be divisible by 4."]
    pub fn meshopt_decodeFilterOct(
        buffer: *mut ::std::os::raw::c_void,
        count: usize,
        stride: usize,
    );
}
extern "C" {
    pub fn meshopt_decodeFilterQuat(
        buffer: *mut ::std::os::raw::c_void,
        count: usize,
        stride: usize,
    );
}
extern "C" {
    pub fn meshopt_decodeFilterExp(
        buffer: *mut ::std::os::raw::c_void,
        count: usize,
        stride: usize,
    );
}
pub const meshopt_EncodeExpMode_meshopt_EncodeExpSeparate: meshopt_EncodeExpMode = 0;
pub const meshopt_EncodeExpMode_meshopt_EncodeExpSharedVector: meshopt_EncodeExpMode = 1;
pub const meshopt_EncodeExpMode_meshopt_EncodeExpSharedComponent: meshopt_EncodeExpMode = 2;
pub const meshopt_EncodeExpMode_meshopt_EncodeExpClamped: meshopt_EncodeExpMode = 3;
#[doc = " Vertex buffer filter encoders\n These functions can be used to encode data in a format that meshopt_decodeFilter can decode\n\n meshopt_encodeFilterOct encodes unit vectors with K-bit (K <= 16) signed X/Y as an output.\n Each component is stored as an 8-bit or 16-bit normalized integer; stride must be equal to 4 or 8. W is preserved as is.\n Input data must contain 4 floats for every vector (count*4 total).\n\n meshopt_encodeFilterQuat encodes unit quaternions with K-bit (4 <= K <= 16) component encoding.\n Each component is stored as an 16-bit integer; stride must be equal to 8.\n Input data must contain 4 floats for every quaternion (count*4 total).\n\n meshopt_encodeFilterExp encodes arbitrary (finite) floating-point data with 8-bit exponent and K-bit integer mantissa (1 <= K <= 24).\n Exponent can be shared between all components of a given vector as defined by stride or all values of a given component; stride must be divisible by 4.\n Input data must contain stride/4 floats for every vector (count*stride/4 total)."]
pub type meshopt_EncodeExpMode = ::std::os::raw::c_int;
extern "C" {
    pub fn meshopt_encodeFilterOct(
        destination: *mut ::std::os::raw::c_void,
        count: usize,
        stride: usize,
        bits: ::std::os::raw::c_int,
        data: *const f32,
    );
}
extern "C" {
    pub fn meshopt_encodeFilterQuat(
        destination: *mut ::std::os::raw::c_void,
        count: usize,
        stride: usize,
        bits: ::std::os::raw::c_int,
        data: *const f32,
    );
}
extern "C" {
    pub fn meshopt_encodeFilterExp(
        destination: *mut ::std::os::raw::c_void,
        count: usize,
        stride: usize,
        bits: ::std::os::raw::c_int,
        data: *const f32,
        mode: meshopt_EncodeExpMode,
    );
}
extern "C" {
    #[doc = " Mesh simplifier\n Reduces the number of triangles in the mesh, attempting to preserve mesh appearance as much as possible\n The algorithm tries to preserve mesh topology and can stop short of the target goal based on topology constraints or target error.\n If not all attributes from the input mesh are required, it's recommended to reindex the mesh without them prior to simplification.\n Returns the number of indices after simplification, with destination containing new index data\n The resulting index buffer references vertices from the original vertex buffer.\n If the original vertex data isn't required, creating a compact vertex buffer using meshopt_optimizeVertexFetch is recommended.\n\n destination must contain enough space for the target index buffer, worst case is index_count elements (*not* target_index_count)!\n vertex_positions should have float3 position in the first 12 bytes of each vertex\n target_error represents the error relative to mesh extents that can be tolerated, e.g. 0.01 = 1% deformation; value range [0..1]\n options must be a bitmask composed of meshopt_SimplifyX options; 0 is a safe default\n result_error can be NULL; when it's not NULL, it will contain the resulting (relative) error after simplification"]
    pub fn meshopt_simplify(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
        target_index_count: usize,
        target_error: f32,
        options: ::std::os::raw::c_uint,
        result_error: *mut f32,
    ) -> usize;
}
extern "C" {
    #[doc = " Mesh simplifier with attribute metric\n The algorithm enhances meshopt_simplify by incorporating attribute values into the error metric used to prioritize simplification order; see meshopt_simplify documentation for details.\n Note that the number of attributes affects memory requirements and running time; this algorithm requires ~1.5x more memory and time compared to meshopt_simplify when using 4 scalar attributes.\n\n vertex_attributes should have attribute_count floats for each vertex\n attribute_weights should have attribute_count floats in total; the weights determine relative priority of attributes between each other and wrt position\n attribute_count must be <= 32\n vertex_lock can be NULL; when it's not NULL, it should have a value for each vertex; 1 denotes vertices that can't be moved"]
    pub fn meshopt_simplifyWithAttributes(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
        vertex_attributes: *const f32,
        vertex_attributes_stride: usize,
        attribute_weights: *const f32,
        attribute_count: usize,
        vertex_lock: *const ::std::os::raw::c_uchar,
        target_index_count: usize,
        target_error: f32,
        options: ::std::os::raw::c_uint,
        result_error: *mut f32,
    ) -> usize;
}
extern "C" {
    #[doc = " Experimental: Mesh simplifier (sloppy)\n Reduces the number of triangles in the mesh, sacrificing mesh appearance for simplification performance\n The algorithm doesn't preserve mesh topology but can stop short of the target goal based on target error.\n Returns the number of indices after simplification, with destination containing new index data\n The resulting index buffer references vertices from the original vertex buffer.\n If the original vertex data isn't required, creating a compact vertex buffer using meshopt_optimizeVertexFetch is recommended.\n\n destination must contain enough space for the target index buffer, worst case is index_count elements (*not* target_index_count)!\n vertex_positions should have float3 position in the first 12 bytes of each vertex\n target_error represents the error relative to mesh extents that can be tolerated, e.g. 0.01 = 1% deformation; value range [0..1]\n result_error can be NULL; when it's not NULL, it will contain the resulting (relative) error after simplification"]
    pub fn meshopt_simplifySloppy(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
        target_index_count: usize,
        target_error: f32,
        result_error: *mut f32,
    ) -> usize;
}
extern "C" {
    #[doc = " Point cloud simplifier\n Reduces the number of points in the cloud to reach the given target\n Returns the number of points after simplification, with destination containing new index data\n The resulting index buffer references vertices from the original vertex buffer.\n If the original vertex data isn't required, creating a compact vertex buffer using meshopt_optimizeVertexFetch is recommended.\n\n destination must contain enough space for the target index buffer (target_vertex_count elements)\n vertex_positions should have float3 position in the first 12 bytes of each vertex\n vertex_colors can be NULL; when it's not NULL, it should have float3 color in the first 12 bytes of each vertex\n color_weight determines relative priority of color wrt position; 1.0 is a safe default"]
    pub fn meshopt_simplifyPoints(
        destination: *mut ::std::os::raw::c_uint,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
        vertex_colors: *const f32,
        vertex_colors_stride: usize,
        color_weight: f32,
        target_vertex_count: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Returns the error scaling factor used by the simplifier to convert between absolute and relative extents\n\n Absolute error must be *divided* by the scaling factor before passing it to meshopt_simplify as target_error\n Relative error returned by meshopt_simplify via result_error must be *multiplied* by the scaling factor to get absolute error."]
    pub fn meshopt_simplifyScale(
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
    ) -> f32;
}
extern "C" {
    #[doc = " Mesh stripifier\n Converts a previously vertex cache optimized triangle list to triangle strip, stitching strips using restart index or degenerate triangles\n Returns the number of indices in the resulting strip, with destination containing new index data\n For maximum efficiency the index buffer being converted has to be optimized for vertex cache first.\n Using restart indices can result in ~10% smaller index buffers, but on some GPUs restart indices may result in decreased performance.\n\n destination must contain enough space for the target index buffer, worst case can be computed with meshopt_stripifyBound\n restart_index should be 0xffff or 0xffffffff depending on index size, or 0 to use degenerate triangles"]
    pub fn meshopt_stripify(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
        restart_index: ::std::os::raw::c_uint,
    ) -> usize;
}
extern "C" {
    pub fn meshopt_stripifyBound(index_count: usize) -> usize;
}
extern "C" {
    #[doc = " Mesh unstripifier\n Converts a triangle strip to a triangle list\n Returns the number of indices in the resulting list, with destination containing new index data\n\n destination must contain enough space for the target index buffer, worst case can be computed with meshopt_unstripifyBound"]
    pub fn meshopt_unstripify(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        restart_index: ::std::os::raw::c_uint,
    ) -> usize;
}
extern "C" {
    pub fn meshopt_unstripifyBound(index_count: usize) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct meshopt_VertexCacheStatistics {
    pub vertices_transformed: ::std::os::raw::c_uint,
    pub warps_executed: ::std::os::raw::c_uint,
    pub acmr: f32,
    pub atvr: f32,
}
extern "C" {
    #[doc = " Vertex transform cache analyzer\n Returns cache hit statistics using a simplified FIFO model\n Results may not match actual GPU performance"]
    pub fn meshopt_analyzeVertexCache(
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
        cache_size: ::std::os::raw::c_uint,
        warp_size: ::std::os::raw::c_uint,
        primgroup_size: ::std::os::raw::c_uint,
    ) -> meshopt_VertexCacheStatistics;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct meshopt_OverdrawStatistics {
    pub pixels_covered: ::std::os::raw::c_uint,
    pub pixels_shaded: ::std::os::raw::c_uint,
    pub overdraw: f32,
}
extern "C" {
    #[doc = " Overdraw analyzer\n Returns overdraw statistics using a software rasterizer\n Results may not match actual GPU performance\n\n vertex_positions should have float3 position in the first 12 bytes of each vertex"]
    pub fn meshopt_analyzeOverdraw(
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
    ) -> meshopt_OverdrawStatistics;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct meshopt_VertexFetchStatistics {
    pub bytes_fetched: ::std::os::raw::c_uint,
    pub overfetch: f32,
}
extern "C" {
    #[doc = " Vertex fetch cache analyzer\n Returns cache hit statistics using a simplified direct mapped model\n Results may not match actual GPU performance"]
    pub fn meshopt_analyzeVertexFetch(
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
        vertex_size: usize,
    ) -> meshopt_VertexFetchStatistics;
}
#[doc = " Meshlet is a small mesh cluster (subset) that consists of:\n - triangles, an 8-bit micro triangle (index) buffer, that for each triangle specifies three local vertices to use;\n - vertices, a 32-bit vertex indirection buffer, that for each local vertex specifies which mesh vertex to fetch vertex attributes from.\n\n For efficiency, meshlet triangles and vertices are packed into two large arrays; this structure contains offsets and counts to access the data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct meshopt_Meshlet {
    pub vertex_offset: ::std::os::raw::c_uint,
    pub triangle_offset: ::std::os::raw::c_uint,
    pub vertex_count: ::std::os::raw::c_uint,
    pub triangle_count: ::std::os::raw::c_uint,
}
extern "C" {
    #[doc = " Meshlet builder\n Splits the mesh into a set of meshlets where each meshlet has a micro index buffer indexing into meshlet vertices that refer to the original vertex buffer\n The resulting data can be used to render meshes using NVidia programmable mesh shading pipeline, or in other cluster-based renderers.\n When targeting mesh shading hardware, for maximum efficiency meshlets should be further optimized using meshopt_optimizeMeshlet.\n When using buildMeshlets, vertex positions need to be provided to minimize the size of the resulting clusters.\n When using buildMeshletsScan, for maximum efficiency the index buffer being converted has to be optimized for vertex cache first.\n\n meshlets must contain enough space for all meshlets, worst case size can be computed with meshopt_buildMeshletsBound\n meshlet_vertices must contain enough space for all meshlets, worst case size is equal to max_meshlets * max_vertices\n meshlet_triangles must contain enough space for all meshlets, worst case size is equal to max_meshlets * max_triangles * 3\n vertex_positions should have float3 position in the first 12 bytes of each vertex\n max_vertices and max_triangles must not exceed implementation limits (max_vertices <= 256, max_triangles <= 512; max_triangles must be divisible by 4)\n cone_weight should be set to 0 when cone culling is not used, and a value between 0 and 1 otherwise to balance between cluster size and cone culling efficiency"]
    pub fn meshopt_buildMeshlets(
        meshlets: *mut meshopt_Meshlet,
        meshlet_vertices: *mut ::std::os::raw::c_uint,
        meshlet_triangles: *mut ::std::os::raw::c_uchar,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
        max_vertices: usize,
        max_triangles: usize,
        cone_weight: f32,
    ) -> usize;
}
extern "C" {
    pub fn meshopt_buildMeshletsScan(
        meshlets: *mut meshopt_Meshlet,
        meshlet_vertices: *mut ::std::os::raw::c_uint,
        meshlet_triangles: *mut ::std::os::raw::c_uchar,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_count: usize,
        max_vertices: usize,
        max_triangles: usize,
    ) -> usize;
}
extern "C" {
    pub fn meshopt_buildMeshletsBound(
        index_count: usize,
        max_vertices: usize,
        max_triangles: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Experimental: Meshlet builder with flexible cluster sizes\n Splits the mesh into a set of meshlets, similarly to meshopt_buildMeshlets, but allows to specify minimum and maximum number of triangles per meshlet.\n Clusters between min and max triangle counts are split when the cluster size would have exceeded the expected cluster size by more than split_factor.\n Additionally, allows to switch to axis aligned clusters by setting cone_weight to a negative value.\n\n meshlets must contain enough space for all meshlets, worst case size can be computed with meshopt_buildMeshletsBound using min_triangles (not max!)\n meshlet_vertices must contain enough space for all meshlets, worst case size is equal to max_meshlets * max_vertices\n meshlet_triangles must contain enough space for all meshlets, worst case size is equal to max_meshlets * max_triangles * 3\n vertex_positions should have float3 position in the first 12 bytes of each vertex\n max_vertices, min_triangles and max_triangles must not exceed implementation limits (max_vertices <= 256, max_triangles <= 512; min_triangles <= max_triangles; both min_triangles and max_triangles must be divisible by 4)\n cone_weight should be set to 0 when cone culling is not used, and a value between 0 and 1 otherwise to balance between cluster size and cone culling efficiency; additionally, cone_weight can be set to a negative value to prioritize axis aligned clusters (for raytracing) instead\n split_factor should be set to a non-negative value; when greater than 0, clusters that have large bounds may be split unless they are under the min_triangles threshold"]
    pub fn meshopt_buildMeshletsFlex(
        meshlets: *mut meshopt_Meshlet,
        meshlet_vertices: *mut ::std::os::raw::c_uint,
        meshlet_triangles: *mut ::std::os::raw::c_uchar,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
        max_vertices: usize,
        min_triangles: usize,
        max_triangles: usize,
        cone_weight: f32,
        split_factor: f32,
    ) -> usize;
}
extern "C" {
    #[doc = " Meshlet optimizer\n Reorders meshlet vertices and triangles to maximize locality to improve rasterizer throughput\n\n meshlet_triangles and meshlet_vertices must refer to meshlet triangle and vertex index data; when buildMeshlets* is used, these\n need to be computed from meshlet's vertex_offset and triangle_offset\n triangle_count and vertex_count must not exceed implementation limits (vertex_count <= 256, triangle_count <= 512)"]
    pub fn meshopt_optimizeMeshlet(
        meshlet_vertices: *mut ::std::os::raw::c_uint,
        meshlet_triangles: *mut ::std::os::raw::c_uchar,
        triangle_count: usize,
        vertex_count: usize,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct meshopt_Bounds {
    pub center: [f32; 3usize],
    pub radius: f32,
    pub cone_apex: [f32; 3usize],
    pub cone_axis: [f32; 3usize],
    pub cone_cutoff: f32,
    pub cone_axis_s8: [::std::os::raw::c_schar; 3usize],
    pub cone_cutoff_s8: ::std::os::raw::c_schar,
}
extern "C" {
    #[doc = " Cluster bounds generator\n Creates bounding volumes that can be used for frustum, backface and occlusion culling.\n\n For backface culling with orthographic projection, use the following formula to reject backfacing clusters:\n   dot(view, cone_axis) >= cone_cutoff\n\n For perspective projection, you can use the formula that needs cone apex in addition to axis & cutoff:\n   dot(normalize(cone_apex - camera_position), cone_axis) >= cone_cutoff\n\n Alternatively, you can use the formula that doesn't need cone apex and uses bounding sphere instead:\n   dot(normalize(center - camera_position), cone_axis) >= cone_cutoff + radius / length(center - camera_position)\n or an equivalent formula that doesn't have a singularity at center = camera_position:\n   dot(center - camera_position, cone_axis) >= cone_cutoff * length(center - camera_position) + radius\n\n The formula that uses the apex is slightly more accurate but needs the apex; if you are already using bounding sphere\n to do frustum/occlusion culling, the formula that doesn't use the apex may be preferable (for derivation see\n Real-Time Rendering 4th Edition, section 19.3).\n\n vertex_positions should have float3 position in the first 12 bytes of each vertex\n vertex_count should specify the number of vertices in the entire mesh, not cluster or meshlet\n index_count/3 and triangle_count must not exceed implementation limits (<= 512)"]
    pub fn meshopt_computeClusterBounds(
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
    ) -> meshopt_Bounds;
}
extern "C" {
    pub fn meshopt_computeMeshletBounds(
        meshlet_vertices: *const ::std::os::raw::c_uint,
        meshlet_triangles: *const ::std::os::raw::c_uchar,
        triangle_count: usize,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
    ) -> meshopt_Bounds;
}
extern "C" {
    #[doc = " Experimental: Sphere bounds generator\n Creates bounding sphere around a set of points or a set of spheres; returns the center and radius of the sphere, with other fields of the result set to 0.\n\n positions should have float3 position in the first 12 bytes of each element\n radii can be NULL; when it's not NULL, it should have a non-negative float radius in the first 4 bytes of each element"]
    pub fn meshopt_computeSphereBounds(
        positions: *const f32,
        count: usize,
        positions_stride: usize,
        radii: *const f32,
        radii_stride: usize,
    ) -> meshopt_Bounds;
}
extern "C" {
    #[doc = " Experimental: Cluster partitioner\n Partitions clusters into groups of similar size, prioritizing grouping clusters that share vertices.\n\n destination must contain enough space for the resulting partiotion data (cluster_count elements)\n destination[i] will contain the partition id for cluster i, with the total number of partitions returned by the function\n cluster_indices should have the vertex indices referenced by each cluster, stored sequentially\n cluster_index_counts should have the number of indices in each cluster; sum of all cluster_index_counts must be equal to total_index_count\n target_partition_size is a target size for each partition, in clusters; the resulting partitions may be smaller or larger"]
    pub fn meshopt_partitionClusters(
        destination: *mut ::std::os::raw::c_uint,
        cluster_indices: *const ::std::os::raw::c_uint,
        total_index_count: usize,
        cluster_index_counts: *const ::std::os::raw::c_uint,
        cluster_count: usize,
        vertex_count: usize,
        target_partition_size: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Spatial sorter\n Generates a remap table that can be used to reorder points for spatial locality.\n Resulting remap table maps old vertices to new vertices and can be used in meshopt_remapVertexBuffer.\n\n destination must contain enough space for the resulting remap table (vertex_count elements)\n vertex_positions should have float3 position in the first 12 bytes of each vertex"]
    pub fn meshopt_spatialSortRemap(
        destination: *mut ::std::os::raw::c_uint,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
    );
}
extern "C" {
    #[doc = " Experimental: Spatial sorter\n Reorders triangles for spatial locality, and generates a new index buffer. The resulting index buffer can be used with other functions like optimizeVertexCache.\n\n destination must contain enough space for the resulting index buffer (index_count elements)\n vertex_positions should have float3 position in the first 12 bytes of each vertex"]
    pub fn meshopt_spatialSortTriangles(
        destination: *mut ::std::os::raw::c_uint,
        indices: *const ::std::os::raw::c_uint,
        index_count: usize,
        vertex_positions: *const f32,
        vertex_count: usize,
        vertex_positions_stride: usize,
    );
}
extern "C" {
    #[doc = " Quantize a float into half-precision (as defined by IEEE-754 fp16) floating point value\n Generates +-inf for overflow, preserves NaN, flushes denormals to zero, rounds to nearest\n Representable magnitude range: [6e-5; 65504]\n Maximum relative reconstruction error: 5e-4"]
    pub fn meshopt_quantizeHalf(v: f32) -> ::std::os::raw::c_ushort;
}
extern "C" {
    #[doc = " Quantize a float into a floating point value with a limited number of significant mantissa bits, preserving the IEEE-754 fp32 binary representation\n Generates +-inf for overflow, preserves NaN, flushes denormals to zero, rounds to nearest\n Assumes N is in a valid mantissa precision range, which is 1..23"]
    pub fn meshopt_quantizeFloat(v: f32, N: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    #[doc = " Reverse quantization of a half-precision (as defined by IEEE-754 fp16) floating point value\n Preserves Inf/NaN, flushes denormals to zero"]
    pub fn meshopt_dequantizeHalf(h: ::std::os::raw::c_ushort) -> f32;
}
extern "C" {
    #[doc = " Set allocation callbacks\n These callbacks will be used instead of the default operator new/operator delete for all temporary allocations in the library.\n Note that all algorithms only allocate memory for temporary use.\n allocate/deallocate are always called in a stack-like order - last pointer to be allocated is deallocated first."]
    pub fn meshopt_setAllocator(
        allocate: ::std::option::Option<
            unsafe extern "C" fn(arg1: usize) -> *mut ::std::os::raw::c_void,
        >,
        deallocate: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
